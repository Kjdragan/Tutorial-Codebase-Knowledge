<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>05 Youtube Data Utilities</title>
    <style>
        pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #f8f8f8; }
.highlight .c { color: #3D7B7B; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #F00 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666 } /* Operator */
.highlight .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #9C6500 } /* Comment.Preproc */
.highlight .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.highlight .gr { color: #E40000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #008400 } /* Generic.Inserted */
.highlight .go { color: #717171 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #04D } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #687822 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #00F; font-weight: bold } /* Name.Class */
.highlight .no { color: #800 } /* Name.Constant */
.highlight .nd { color: #A2F } /* Name.Decorator */
.highlight .ni { color: #717171; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #00F } /* Name.Function */
.highlight .nl { color: #767600 } /* Name.Label */
.highlight .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.highlight .w { color: #BBB } /* Text.Whitespace */
.highlight .mb { color: #666 } /* Literal.Number.Bin */
.highlight .mf { color: #666 } /* Literal.Number.Float */
.highlight .mh { color: #666 } /* Literal.Number.Hex */
.highlight .mi { color: #666 } /* Literal.Number.Integer */
.highlight .mo { color: #666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #A45A77 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #00F } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666 } /* Literal.Number.Integer.Long */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            padding: 10px;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="navigation">
        <a class="nav-link" href="04_topic_processing_orchestrator.html">&larr; Previous</a>
        <a class="nav-link" href="index.html">Index</a>
        <a class="nav-link" href="06_llm_utility.html">Next &rarr;</a>
    </div>
    <h1>Chapter 5: YouTube Data Utilities</h1>

<p>Welcome back! In the previous chapter, <a rel="noopener" target="_blank" href="04_topic_processing_orchestrator.md">Topic Processing Orchestrator</a>, we saw how our pipeline cleverly analyzes multiple topics from a video transcript in parallel. We also saw in earlier chapters how Nodes like <code>InputProcessingNode</code> and <code>ContentExtractionNode</code> magically seem to get information <em>about</em> the video (like its title) and its transcript (the spoken words).</p>

<p>But where does this information actually <em>come from</em>? How does our program talk to YouTube? That's where our <strong>YouTube Data Utilities</strong> come in!</p>

<h2>The Problem: Getting Data <em>From</em> YouTube</h2>

<p>Our summarizer project starts with just one thing: a YouTube video URL (like <code>https://www.youtube.com/watch?v=some_video_id</code>). To do anything useful, we need to extract specific pieces of information directly related to that URL:</p>

<ol>
<li><strong>Is this even a real YouTube link?</strong> We need to check if the URL points to a valid YouTube video before we try to process it.</li>
<li><strong>What is this video about?</strong> We need basic details like the video's title, the channel that uploaded it, and maybe how long it is (its duration). We call this "metadata".</li>
<li><strong>What is being said in the video?</strong> For topic analysis and summarization, we crucially need the spoken words, known as the transcript or captions.</li>
</ol>

<p>Simply having the URL isn't enough. We need tools to interact with YouTube (or YouTube data sources) to fetch this information.</p>

<h2>Our Solution: Specialized YouTube Tools (Utilities)</h2>

<p>Imagine you have a toolbox. You don't just have one giant "Do-Everything" tool. You have specific tools for specific jobs: a screwdriver for screws, a wrench for bolts, a hammer for nails.</p>

<p>Our <strong>YouTube Data Utilities</strong> are like these specialized tools in our project's toolbox. They are <em>not</em> full pipeline <a rel="noopener" target="_blank" href="02_node__pipeline_step_.md">Nodes (Pipeline Step)</a> themselves. Instead, they are smaller, focused helper functions that our Nodes <em>use</em> to perform specific tasks related to YouTube.</p>

<p>We have three main utility tools in our <code>src/utils/</code> directory:</p>

<ol>
<li><strong>The Link Checker (<code>validate_youtube_url</code>)</strong>: Checks if a given text string looks like a valid YouTube URL and extracts the unique 11-character video ID.</li>
<li><strong>The Info Fetcher (<code>extract_youtube_metadata</code>)</strong>: Takes a video ID and fetches details like the title, channel name, duration, etc., by talking to YouTube's official Data API.</li>
<li><strong>The Script Grabber (<code>extract_youtube_transcript</code>)</strong>: Takes a video ID and retrieves the transcript (the spoken words) for that video using a specialized library.</li>
</ol>

<p>These utilities live in their own files (like <code>validate_youtube_url.py</code>, <code>extract_youtube_metadata.py</code>, <code>extract_youtube_transcript.py</code>) inside the <code>src/utils/</code> folder, keeping our toolbox organized.</p>

<h2>How Nodes Use These Utilities</h2>

<p>Our pipeline Nodes, which we learned about in <a rel="noopener" target="_blank" href="02_node__pipeline_step_.md">Chapter 2: Node (Pipeline Step)</a>, act like the workers on the assembly line. When a worker needs to perform a YouTube-specific action, they reach into the toolbox and use the appropriate utility. This usually happens inside the Node's <code>exec()</code> method.</p>

<p><strong>Example 1: Input Processing Node using the Link Checker and Info Fetcher</strong></p>

<p>The <code>InputProcessingNode</code>'s job is to take the initial URL, validate it, and get basic video info. Here's a simplified look at how its <code>exec</code> method might use our utilities:</p>

<div class="codehilite">
<pre><span></span><code><span class="c1"># Simplified from src/nodes/input_processing_node.py</span>

<span class="c1"># Import the utility functions (tools)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.utils.validate_youtube_url</span><span class="w"> </span><span class="kn">import</span> <span class="n">validate_youtube_url</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.utils.extract_youtube_metadata</span><span class="w"> </span><span class="kn">import</span> <span class="n">extract_youtube_metadata</span>
<span class="c1"># ... other imports ...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">InputProcessingNode</span><span class="p">(</span><span class="n">BaseNode</span><span class="p">):</span>
    <span class="c1"># ... (prep method gets the URL from shared_memory) ...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Get the URL we stored during prep</span>
        <span class="n">youtube_url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared_memory</span><span class="p">[</span><span class="s2">&quot;video_url&quot;</span><span class="p">]</span>

        <span class="c1"># Use the &#39;Link Checker&#39; utility</span>
        <span class="n">is_valid</span><span class="p">,</span> <span class="n">video_id</span> <span class="o">=</span> <span class="n">validate_youtube_url</span><span class="p">(</span><span class="n">youtube_url</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid</span><span class="p">:</span>
            <span class="c1"># If the link is bad, report an error and stop</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shared_memory</span><span class="p">[</span><span class="s2">&quot;error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Invalid YouTube URL&quot;</span>
            <span class="k">return</span>

        <span class="c1"># Store the extracted video ID in shared memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared_memory</span><span class="p">[</span><span class="s2">&quot;video_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">video_id</span>

        <span class="c1"># Use the &#39;Info Fetcher&#39; utility with the video ID</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">extract_youtube_metadata</span><span class="p">(</span><span class="n">video_id</span><span class="p">)</span>

        <span class="c1"># Check if fetching metadata failed</span>
        <span class="k">if</span> <span class="s2">&quot;error&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shared_memory</span><span class="p">[</span><span class="s2">&quot;error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;error&quot;</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="c1"># Store the fetched metadata in shared memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared_memory</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata</span>

    <span class="c1"># ... (post method logs success or failure) ...</span>
</code></pre>
</div>

<p>In this snippet:</p>

<ol>
<li>The Node calls <code>validate_youtube_url</code> with the input URL.</li>
<li>If valid, it gets back <code>True</code> and the <code>video_id</code>. It stores the <code>video_id</code> in <a rel="noopener" target="_blank" href="03_shared_memory.md">Shared Memory</a>.</li>
<li>It then calls <code>extract_youtube_metadata</code> with the <code>video_id</code>.</li>
<li>If successful, it gets back a dictionary of metadata (title, channel, etc.) and stores it in <a rel="noopener" target="_blank" href="03_shared_memory.md">Shared Memory</a>.</li>
</ol>

<p><strong>Example 2: Content Extraction Node using the Script Grabber</strong></p>

<p>The <code>ContentExtractionNode</code>'s job is to get the transcript. It expects the <code>video_id</code> to already be in <a rel="noopener" target="_blank" href="03_shared_memory.md">Shared Memory</a> (put there by the <code>InputProcessingNode</code>).</p>

<div class="codehilite">
<pre><span></span><code><span class="c1"># Simplified from src/nodes/content_extraction_node.py</span>

<span class="c1"># Import the utility function (tool)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.utils.extract_youtube_transcript</span><span class="w"> </span><span class="kn">import</span> <span class="n">extract_youtube_transcript</span>
<span class="c1"># ... other imports ...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ContentExtractionNode</span><span class="p">(</span><span class="n">BaseNode</span><span class="p">):</span>
    <span class="c1"># ... (prep method gets video_id from shared_memory) ...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Get the video_id we stored during prep</span>
        <span class="n">video_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared_memory</span><span class="p">[</span><span class="s2">&quot;video_id&quot;</span><span class="p">]</span>

        <span class="c1"># Use the &#39;Script Grabber&#39; utility</span>
        <span class="n">transcript_text</span> <span class="o">=</span> <span class="n">extract_youtube_transcript</span><span class="p">(</span><span class="n">video_id</span><span class="p">)</span>

        <span class="c1"># Check if fetching the transcript failed</span>
        <span class="k">if</span> <span class="n">transcript_text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Error:&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shared_memory</span><span class="p">[</span><span class="s2">&quot;error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transcript_text</span>
            <span class="k">return</span>

        <span class="c1"># Store the fetched transcript in shared memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared_memory</span><span class="p">[</span><span class="s2">&quot;transcript&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transcript_text</span>

    <span class="c1"># ... (post method logs success or failure) ...</span>
</code></pre>
</div>

<p>Here:</p>

<ol>
<li>The Node gets the <code>video_id</code> from <a rel="noopener" target="_blank" href="03_shared_memory.md">Shared Memory</a>.</li>
<li>It calls <code>extract_youtube_transcript</code> with the <code>video_id</code>.</li>
<li>If successful, it gets back the transcript text as a string and stores it in <a rel="noopener" target="_blank" href="03_shared_memory.md">Shared Memory</a> under the key <code>"transcript"</code>.</li>
</ol>

<p>These examples show how Nodes delegate specific YouTube interactions to our utility functions, keeping the Node's code focused on its main workflow (<code>prep</code>, <code>exec</code>, <code>post</code>).</p>

<h2>Under the Hood: How the Utilities Work</h2>

<p>Let's briefly peek inside the toolbox and see how these tools operate.</p>

<p><strong>1. Link Checker (<code>validate_youtube_url</code>)</strong></p>

<p>This utility doesn't actually connect to the internet. It just looks at the structure of the URL string you give it. It uses pattern matching (specifically, "regular expressions") to see if the URL <em>looks like</em> common YouTube video links (e.g., <code>youtube.com/watch?v=...</code> or <code>youtu.be/...</code>). If it finds a match, it extracts the 11-character part that is the video ID.</p>

<div class="codehilite">
<pre><span></span><code><span class="c1"># Simplified from src/utils/validate_youtube_url.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span> <span class="c1"># Python&#39;s regular expression module</span>

<span class="k">def</span><span class="w"> </span><span class="nf">validate_youtube_url</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># A pattern to match YouTube URLs and capture the ID</span>
    <span class="n">youtube_regex</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">r</span><span class="s1">&#39;(https?://)?(www\.)?&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;(youtube|youtu|youtube-nocookie)\.(com|be)/&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;(watch\?v=|embed/|v/|.+\?v=)?([^&amp;=%\?]</span><span class="si">{11}</span><span class="s1">)&#39;</span> <span class="c1"># Capture 11 chars</span>
    <span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">youtube_regex</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="n">video_id</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="c1"># Get the captured ID part</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">video_id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># (Also checks other formats like youtu.be/...)</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
</code></pre>
</div>

<p><strong>2. Info Fetcher (<code>extract_youtube_metadata</code>)</strong></p>

<p>This utility <em>does</em> connect to the internet. It talks to the official <strong>YouTube Data API</strong>, which is a service provided by Google/YouTube for developers to get video information programmatically.</p>

<ul>
<li><strong>Needs an API Key:</strong> To use this API, you usually need a special key (like a password) to identify yourself. Our utility looks for this key (you'll need to get one from Google and configure it for the project).</li>
<li><strong>Makes a Request:</strong> It sends the <code>video_id</code> and the API key to a specific Google web address.</li>
<li><strong>Gets a Response:</strong> Google sends back structured data (in JSON format) containing the video's title, description, channel, duration, view count, etc.</li>
<li><strong>Parses the Response:</strong> The utility extracts the useful bits from the JSON response and returns them as a Python dictionary.</li>
</ul>

<pre><code>sequenceDiagram
    participant Node as InputProcessingNode
    participant MetadataUtil as extract_youtube_metadata()
    participant YT_API as YouTube Data API (Google)

    Node-&gt;&gt;MetadataUtil: extract_youtube_metadata("some_video_id")
    Note over MetadataUtil: Needs API Key!
    MetadataUtil-&gt;&gt;YT_API: GET /youtube/v3/videos?id=some_video_id&amp;key=API_KEY&amp;part=snippet...
    YT_API--&gt;&gt;MetadataUtil: Return JSON data { "items": [ { "snippet": { "title": "...", ... } } ] }
    MetadataUtil-&gt;&gt;MetadataUtil: Parse JSON, extract title, channel, etc.
    MetadataUtil--&gt;&gt;Node: Return metadata_dictionary
</code></pre>

<div class="codehilite">
<pre><span></span><code><span class="c1"># Simplified from src/utils/extract_youtube_metadata.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">requests</span> <span class="c1"># Library to make web requests</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="k">def</span><span class="w"> </span><span class="nf">extract_youtube_metadata</span><span class="p">(</span><span class="n">video_id</span><span class="p">):</span>
    <span class="c1"># Get API key (needs to be set up separately)</span>
    <span class="n">api_key</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;YOUTUBE_API_KEY&quot;</span><span class="p">,</span> <span class="s2">&quot;YOUR_API_KEY&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">api_key</span> <span class="o">==</span> <span class="s2">&quot;YOUR_API_KEY&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="s2">&quot;YouTube API Key not configured&quot;</span><span class="p">}</span>

    <span class="n">api_url</span> <span class="o">=</span> <span class="s2">&quot;https://www.googleapis.com/youtube/v3/videos&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;part&quot;</span><span class="p">:</span> <span class="s2">&quot;snippet,contentDetails,statistics&quot;</span><span class="p">,</span> <span class="c1"># Ask for specific info</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">video_id</span><span class="p">,</span>
        <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">api_key</span>
    <span class="p">}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">api_url</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span> <span class="c1"># Check for web errors (like 404)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span> <span class="c1"># Parse the JSON response</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;items&quot;</span><span class="p">):</span>
             <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="s2">&quot;Video not found or API key invalid&quot;</span><span class="p">}</span>

        <span class="c1"># ... (code to extract title, channel, duration etc. from data) ...</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;...&quot;</span><span class="p">,</span> <span class="s2">&quot;channel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;...&quot;</span><span class="p">,</span> <span class="o">...</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">metadata</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;API request error: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
</code></pre>
</div>

<p><strong>3. Script Grabber (<code>extract_youtube_transcript</code>)</strong></p>

<p>This utility uses a third-party Python library called <code>youtube_transcript_api</code>. This library knows how to find and download the captions or transcripts that YouTube provides for many videos.</p>

<ul>
<li><strong>Uses the Library:</strong> It calls functions from the <code>youtube_transcript_api</code> library, passing the <code>video_id</code>.</li>
<li><strong>Library Handles Complexity:</strong> The library deals with finding available languages, downloading the transcript data (which includes text and timing information), and potentially translating it if needed.</li>
<li><strong>Returns Text:</strong> Our utility simplifies the result, combining all the text pieces into one single string and returning it. It also handles cases where transcripts are disabled or not found.</li>
</ul>

<div class="codehilite">
<pre><span></span><code><span class="c1"># Simplified from src/utils/extract_youtube_transcript.py</span>

<span class="c1"># Import the specialized library</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">youtube_transcript_api</span><span class="w"> </span><span class="kn">import</span> <span class="n">YouTubeTranscriptApi</span><span class="p">,</span> <span class="n">TranscriptsDisabled</span><span class="p">,</span> <span class="n">NoTranscriptFound</span>

<span class="k">def</span><span class="w"> </span><span class="nf">extract_youtube_transcript</span><span class="p">(</span><span class="n">video_id</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Ask the library to find and fetch the transcript (prefer English)</span>
        <span class="n">transcript_list</span> <span class="o">=</span> <span class="n">YouTubeTranscriptApi</span><span class="o">.</span><span class="n">list_transcripts</span><span class="p">(</span><span class="n">video_id</span><span class="p">)</span>
        <span class="n">transcript</span> <span class="o">=</span> <span class="n">transcript_list</span><span class="o">.</span><span class="n">find_transcript</span><span class="p">([</span><span class="s1">&#39;en&#39;</span><span class="p">])</span>
        <span class="n">transcript_data</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>

        <span class="c1"># Combine the text parts into one string</span>
        <span class="n">full_transcript</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">transcript_data</span><span class="p">:</span>
            <span class="n">full_transcript</span> <span class="o">+=</span> <span class="n">segment</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>

        <span class="k">return</span> <span class="n">full_transcript</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="k">except</span> <span class="n">TranscriptsDisabled</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;Error: Transcripts are disabled for this video.&quot;</span>
    <span class="k">except</span> <span class="n">NoTranscriptFound</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;Error: No transcript found for this video.&quot;</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Error extracting transcript: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre>
</div>

<h2>Conclusion</h2>

<p>In this chapter, we opened up the toolbox and looked at our <strong>YouTube Data Utilities</strong>. These are essential helper functions that allow our project to interact directly with YouTube data.</p>

<ul>
<li>They are <strong>specialized tools</strong> for specific tasks: validating URLs, fetching metadata, and grabbing transcripts.</li>
<li>They are <strong>not Nodes</strong>, but rather <strong>used by Nodes</strong> (like <code>InputProcessingNode</code> and <code>ContentExtractionNode</code>) within their <code>exec</code> methods.</li>
<li>They live in the <code>src/utils/</code> directory, keeping our code organized.</li>
<li>They handle the details of pattern matching (<code>validate_youtube_url</code>), talking to the YouTube Data API (<code>extract_youtube_metadata</code>), and using libraries to get transcripts (<code>extract_youtube_transcript</code>).</li>
</ul>

<p>These utilities provide the raw materials (metadata, transcript) that the rest of our pipeline (<a rel="noopener" target="_blank" href="01_pipeline_orchestration.md">Pipeline Orchestration</a>) processes to create the final summary.</p>

<p>Now that we have the video's transcript, how do we actually analyze it to find topics, generate Q&amp;A, or create ELI5 summaries? This often involves using powerful Artificial Intelligence models. Let's explore the utility designed to help us interact with these AI models next.</p>

<p>Ready to see how we talk to the AI? Let's move on to <a rel="noopener" target="_blank" href="06_llm_utility.md">Chapter 6: LLM Utility</a>!</p>

<hr />

<p>Generated by <a rel="noopener" target="_blank" href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>

    <div class="navigation">
        <a class="nav-link" href="04_topic_processing_orchestrator.html">&larr; Previous</a>
        <a class="nav-link" href="index.html">Index</a>
        <a class="nav-link" href="06_llm_utility.html">Next &rarr;</a>
    </div>
</body>
</html>