
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>03 Shared Memory</title>
            
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            background-color: #f5f5f5;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        .nav-link {
            text-decoration: none;
            color: #0366d6;
        }
        .nav-link:hover {
            text-decoration: underline;
        }
        .mermaid {
            text-align: center;
            margin: 20px 0;
        }
    </style>
    
            
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: true,
                theme: 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: false,
                    htmlLabels: true
                },
                sequence: {
                    useMaxWidth: false,
                    htmlLabels: true,
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    boxMargin: 10
                }
            });
        });
    </script>
    
        </head>
        <body>
            
        <div class="navigation">
            <a class="nav-link" href="02_node__pipeline_step_.html">&larr; Previous</a>
            <a class="nav-link" href="index.html">Index</a>
            <a class="nav-link" href="04_topic_processing_orchestrator.html">Next &rarr;</a>
        </div>
        
            <h1>Chapter 3: Shared Memory</h1>
<p>In <a href="01_pipeline_orchestration.md">Chapter 1: Pipeline Orchestration</a>, we saw our pipeline manager (<code>run_pipeline</code>) coordinating the different steps. In <a href="02_node__pipeline_step_.md">Chapter 2: Node (Pipeline Step)</a>, we met the specialized workers (Nodes) that perform each task, like getting the video transcript or finding topics.</p>
<p>But how does the "transcript extractor" Node hand over the transcript it found to the "topic finder" Node? They need a way to pass information along the assembly line. That's where <strong>Shared Memory</strong> comes in!</p>
<h2>The Problem: Passing Notes Between Workers</h2>
<p>Imagine our assembly line again.
1.  Worker A gets the video ID.
2.  Worker B needs that video ID to fetch the transcript.
3.  Worker C needs the transcript to find the main topics.</p>
<p>How does Worker A tell Worker B the video ID? How does Worker B give the transcript to Worker C? They can't just shout across the factory floor! They need a reliable way to share their results.</p>
<h2>Our Solution: The Shared Whiteboard (A Python Dictionary)</h2>
<p>In <code>pf1</code>, the <strong>Shared Memory</strong> is our solution. Think of it like a <strong>shared whiteboard</strong> or a <strong>central notebook</strong> that every worker (Node) in the pipeline can access.</p>
<ul>
<li>When a Node finishes its job, it writes its results onto the whiteboard (e.g., "Video ID: xyz123", "Transcript: Hello world...").</li>
<li>When the next Node starts its job, it looks at the whiteboard to find the information it needs (e.g., it reads the "Transcript" section).</li>
</ul>
<p>Technically, this "whiteboard" is just a standard <strong>Python dictionary</strong>. If you're new to Python dictionaries, they simply store information as <strong>key-value pairs</strong>.</p>
<pre><code class="language-python"># A simple Python dictionary example
my_info = {
  &quot;name&quot;: &quot;Alex&quot;,
  &quot;task&quot;: &quot;Write chapter&quot;,
  &quot;tools&quot;: [&quot;laptop&quot;, &quot;keyboard&quot;]
}

# Accessing information using the key
print(my_info[&quot;name&quot;])  # Output: Alex

# Adding new information
my_info[&quot;status&quot;] = &quot;In progress&quot;
print(my_info)
# Output: {'name': 'Alex', 'task': 'Write chapter', 'tools': ['laptop', 'keyboard'], 'status': 'In progress'}
</code></pre>
<p>Our <code>shared_memory</code> works exactly like this! It's a dictionary where keys are strings describing the data (like <code>"video_url"</code>, <code>"video_id"</code>, <code>"transcript"</code>, <code>"topics"</code>), and the values are the actual data (the URL string, the ID string, the long transcript text, a list of topic strings, etc.).</p>
<h2>How Shared Memory Flows Through the Pipeline</h2>
<ol>
<li>
<p><strong>Initialization:</strong> The pipeline orchestrator (<code>run_pipeline</code> in <code>src/main.py</code>) creates the <code>shared_memory</code> dictionary when the pipeline starts. Initially, it usually just contains the input needed for the very first step, like the YouTube video URL.</p>
<p>```python</p>
<h1>From src/main.py (simplified)</h1>
<p>def run_pipeline(youtube_url, ...):
    # Create the shared memory dictionary
    shared_memory = {"video_url": youtube_url}
    logger.info("Shared memory initialized.")
    # ... rest of the pipeline ...
<code>``
At this point,</code>shared_memory<code>looks like:</code>{"video_url": "https://youtube.com/watch?v=some_id"}`</p>
</li>
<li>
<p><strong>Passing to Nodes:</strong> The orchestrator passes this <code>shared_memory</code> dictionary to the first Node when it calls the Node's <code>run()</code> method.</p>
<p>```python</p>
<h1>From src/main.py (simplified)</h1>
<h1>... inside run_pipeline ...</h1>
<h1>1. Input Processing Node</h1>
<p>logger.info("Calling InputProcessingNode...")
input_node = InputProcessingNode(shared_memory) # Give the Node access
shared_memory = input_node.run() # Node runs and returns the UPDATED dictionary
```</p>
</li>
<li>
<p><strong>Nodes Read and Write:</strong> Inside the Node's <code>run()</code> method, the <code>prep</code>, <code>exec</code>, and <code>post</code> methods interact with the dictionary:</p>
<ul>
<li><strong><code>prep()</code> reads:</strong> It looks up the keys it needs (e.g., the <code>InputProcessingNode</code> reads <code>"video_url"</code>).</li>
<li><strong><code>post()</code> writes:</strong> After <code>exec()</code> does the work, <code>post()</code> adds the Node's results back into the <em>same</em> dictionary using new keys (e.g., the <code>InputProcessingNode</code> adds <code>"video_id"</code> and <code>"metadata"</code>).</li>
</ul>
<p>```python</p>
<h1>Inside InputProcessingNode (simplified)</h1>
<p>def prep(self):
    # Read the URL provided by the orchestrator
    self.url = self.shared_memory["video_url"]
    logger.debug(f"Input node read URL: {self.url}")</p>
<p>def exec(self):
    # Do work: Get video ID and metadata from the URL
    # (Simplified - actual logic calls YouTube utilities)
    self.video_id_result = "xyz123"
    self.metadata_result = {"title": "Cool Video", "author": "Creator"}
    logger.debug("Input node got video ID and metadata.")</p>
<p>def post(self):
    # Write the results back to the dictionary
    self.shared_memory["video_id"] = self.video_id_result
    self.shared_memory["metadata"] = self.metadata_result
    logger.debug("Input node wrote video_id and metadata to shared memory.")
```</p>
</li>
<li>
<p><strong>Passing Updated Memory:</strong> When the Node's <code>run()</code> method finishes, it returns the modified <code>shared_memory</code> dictionary back to the orchestrator. The orchestrator then passes this <em>updated</em> dictionary to the <em>next</em> Node in the sequence.</p>
<p>```python</p>
<h1>From src/main.py (simplified)</h1>
<h1>... after InputProcessingNode runs ...</h1>
<h1>shared_memory now contains:</h1>
<h1>{</h1>
<h1>"video_url": "https://youtube.com/watch?v=some_id",</h1>
<h1>"video_id": "xyz123",</h1>
<h1>"metadata": {"title": "Cool Video", "author": "Creator"}</h1>
<h1>}</h1>
<h1>2. Content Extraction Node</h1>
<p>logger.info("Calling ContentExtractionNode...")
content_node = ContentExtractionNode(shared_memory) # Pass the UPDATED memory
shared_memory = content_node.run() # Get the next update
```</p>
</li>
<li>
<p><strong>Chain Reaction:</strong> This process repeats for every Node in the pipeline. Each Node reads the data left by previous Nodes and adds its own results.</p>
<ul>
<li><code>ContentExtractionNode</code> reads <code>"video_id"</code>, does its work, and adds <code>"transcript"</code>.</li>
<li><code>TopicExtractionNode</code> reads <code>"transcript"</code>, does its work, and adds <code>"topics"</code>.</li>
<li>...and so on.</li>
</ul>
</li>
</ol>
<p>The <code>shared_memory</code> dictionary grows as it passes through the pipeline, accumulating all the results.</p>
<h2>Under the Hood: Passing the Dictionary Around</h2>
<p>Is this some magic "shared" space in the computer's memory? Not really! It's much simpler in our case.</p>
<p>Python dictionaries are "mutable" objects. This means when you pass a dictionary to a function (or a Node's method), you're passing a reference to the <em>exact same</em> dictionary object in memory. If the function modifies the dictionary (like adding a new key), the original dictionary that was passed in also changes.</p>
<p>So, the orchestrator creates <em>one</em> dictionary object. It passes a reference to this object to Node 1. Node 1 modifies it directly. The orchestrator then passes the reference to the <em>same, now modified</em> object to Node 2, and so on.</p>
<p>Here's a diagram showing this flow:</p>
<div class="mermaid">
sequenceDiagram
    participant Orch as run_pipeline (Orchestrator)
    participant SMDict as Shared Memory (Python Dictionary)
    participant NodeA as InputProcessingNode
    participant NodeB as ContentExtractionNode

    Orch->>SMDict: Create { "video_url": "..." }
    Orch->>NodeA: run(reference to SMDict)
    NodeA->>NodeA: prep() [reads "video_url" from SMDict]
    NodeA->>NodeA: exec() [gets video_id, metadata]
    NodeA->>SMDict: post() [adds "video_id", "metadata"]
    NodeA-->>Orch: Return reference to SMDict
    Note right of Orch: SMDict is now modified

    Orch->>NodeB: run(reference to SMDict)
    NodeB->>NodeB: prep() [reads "video_id" from SMDict]
    NodeB->>NodeB: exec() [gets transcript]
    NodeB->>SMDict: post() [adds "transcript"]
    NodeB-->>Orch: Return reference to SMDict
    Note right of Orch: SMDict is now further modified

</div>
<p>It's like passing the <em>same physical notebook</em> from person to person. Each person adds their notes to it before passing it on.</p>
<h2>Example: Reading and Writing</h2>
<p>Let's see how the <code>ContentExtractionNode</code> might read the <code>"video_id"</code> written by <code>InputProcessingNode</code> and then write the <code>"transcript"</code>.</p>
<pre><code class="language-python"># Inside ContentExtractionNode (simplified)

def prep(self):
    # Read the video_id written by the previous node
    if &quot;video_id&quot; in self.shared_memory:
        self.video_id_to_process = self.shared_memory[&quot;video_id&quot;]
        logger.debug(f&quot;Content node read video_id: {self.video_id_to_process}&quot;)
    else:
        # Handle missing data (important!)
        logger.error(&quot;Error: video_id not found in shared memory!&quot;)
        self.shared_memory[&quot;error&quot;] = &quot;Missing video_id for transcript extraction&quot;

def exec(self):
    # Only run if prep was successful (no error)
    if &quot;error&quot; not in self.shared_memory:
        # Use self.video_id_to_process to get the transcript
        # (Simplified - actual logic calls YouTube utilities)
        self.transcript_result = &quot;This is the transcript text...&quot;
        logger.debug(&quot;Content node got the transcript.&quot;)

def post(self):
    # Only run if prep and exec were successful
    if &quot;error&quot; not in self.shared_memory:
        # Write the transcript result to shared memory
        self.shared_memory[&quot;transcript&quot;] = self.transcript_result
        logger.debug(&quot;Content node wrote transcript to shared memory.&quot;)
</code></pre>
<p>This Node first checks if the key <code>"video_id"</code> exists in the <code>shared_memory</code> it received (this is crucial error handling!). If it exists, it uses that ID in its <code>exec</code> step. Finally, in <code>post</code>, it adds its own result under the key <code>"transcript"</code>. The next Node can now read <code>"transcript"</code>.</p>
<h2>Why Use a Dictionary?</h2>
<ul>
<li><strong>Simplicity:</strong> It's a fundamental Python data structure, easy to understand and use.</li>
<li><strong>Flexibility:</strong> Dictionaries can hold various data types (strings, numbers, lists, even other dictionaries), which is perfect for the different kinds of results our Nodes produce.</li>
<li><strong>Clarity:</strong> Using meaningful keys (like <code>"transcript"</code>, <code>"topics"</code>) makes it clear what data is being passed around.</li>
</ul>
<h2>Conclusion</h2>
<p>We've learned about <strong>Shared Memory</strong>, the crucial mechanism that allows our pipeline Nodes to communicate and share data.</p>
<ul>
<li>It's implemented as a simple <strong>Python dictionary</strong>.</li>
<li>The pipeline orchestrator (<a href="01_pipeline_orchestration.md">Chapter 1</a>) creates it and passes it sequentially to each Node (<a href="02_node__pipeline_step_.md">Chapter 2</a>).</li>
<li>Nodes <strong>read</strong> the inputs they need from the dictionary using keys (usually in <code>prep</code>).</li>
<li>Nodes <strong>write</strong> their results back into the dictionary using new keys (usually in <code>post</code>).</li>
<li>This allows data like the video ID, transcript, and topics to flow smoothly from one step to the next.</li>
</ul>
<p>Understanding Shared Memory is key to seeing how the different parts of our <code>pf1</code> project connect and build upon each other's work.</p>
<p>Now that we understand the basic building blocks (Orchestration, Nodes, Shared Memory), we can look at more specialized components. Next, we'll explore a Node that acts as a mini-orchestrator itself, managing the detailed processing of topics.</p>
<p>Let's dive into the <a href="04_topic_processing_orchestrator.md">Topic Processing Orchestrator</a>!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
            
        <div class="navigation">
            <a class="nav-link" href="02_node__pipeline_step_.html">&larr; Previous</a>
            <a class="nav-link" href="index.html">Index</a>
            <a class="nav-link" href="04_topic_processing_orchestrator.html">Next &rarr;</a>
        </div>
        
        </body>
        </html>
        